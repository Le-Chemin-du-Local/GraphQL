directive @hasRole(role: Role!) on FIELD_DEFINITION

enum Role {
  ADMIN,
  STOREKEEPER,
  USER
}

scalar Time

##################
## UTILISATEURS ##
##################

type User {
  id: ID!
  createdAt: Time
  email: String!
  role: String!
  firstName: String
  lastName: String

  commerce: Commerce
}

input NewUser {
  email: String!
  password: String!
  firstName: String
  lastName: String
}

input Login {
  email: String!
  password: String!
}

###############
## COMMERCE ##
###############

# COMMERCE
# Utilisation de la pagination par curseur : https://www.apollographql.com/blog/graphql/pagination/understanding-pagination-rest-graphql-and-relay/

type Commerce { # Ici on utilise le nom "Commerce"
                # plutôt que "Store" pour éviter de 
                # futures conflits
  id: ID!
  storekeeper: User!
  
  # Descriptif
  name: String!
  description: String!
  storekeeperWord: String!

  # Coordonnées
  address: String!
  phone: String!
  email: String!
} 

# Pagination 
type CommerceConnection {
  edges: [CommerceEdge!]!
  pageInfo: CommercePageInfo!
}

type CommerceEdge {
  cursor: ID!
  node: Commerce
}

type CommercePageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewCommerce {
  # Descriptif
  name: String!
  description: String!
  storekeeperWord: String!

  # Coordonnées
  address: String!
  phone: String!
  email: String!
}

type Query {
  # UTILISATEURS
  users: [User!]!
  user(id: ID!): User!

  # COMMERCES
  commerces(first: Int = 5, after: ID): CommerceConnection! 
  commerce(id: ID!): Commerce!
}

type Mutation {
  # UTILISATEURS
  createUser(input: NewUser!): User!
  login(input: Login!): String!

  # COMMERCES
  createCommerce(input: NewCommerce!): Commerce! @hasRole(role: STOREKEEPER) 
}
