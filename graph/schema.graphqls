directive @hasRole(role: Role!) on FIELD_DEFINITION
directive @needAuthentication on FIELD_DEFINITION

enum Role {
  ADMIN,
  STOREKEEPER,
  USER
}

scalar Time
scalar Upload

##################
## UTILISATEURS ##
##################

type User {
  id: ID!
  createdAt: Time
  email: String!
  role: String!
  firstName: String
  lastName: String

  commerce: Commerce
  basket: Basket
}

input NewUser {
  email: String!
  password: String!
  firstName: String
  lastName: String
}

input Login {
  email: String!
  password: String!
}

###############
## COMMERCE ##
###############

# COMMERCE
# Utilisation de la pagination par curseur : https://www.apollographql.com/blog/graphql/pagination/understanding-pagination-rest-graphql-and-relay/

type Commerce { # Ici on utilise le nom "Commerce"
                # plutôt que "Store" pour éviter de 
                # futures conflits
  id: ID!
  storekeeper: User!
  
  # Descriptif
  name: String!
  description: String!
  storekeeperWord: String!

  # Coordonnées
  address: String!
  latitude: Float!
  longitude: Float!
  phone: String!
  email: String!

  facebook: String
  twitter: String
  instagram: String

  # Produits
  categories: [String!]!
  products(first: Int = 10, after: ID, filters: ProductFilter): ProductConnection!

  # Services
  services: [String!]!
  productsAvailableForClickAndCollect: [Product!]!

  # Click and collcet
  cccommands(first: Int = 10, after: ID, filters: CCCommandFilter): CCCommandConnection!

  # Panier
  paniers(first: Int = 10, after: ID, filters: PanierFilter): PanierConnection!
  panierCommands(first: Int = 10, after: ID, filters: PanierCommandFilter): PanierCommandConnection!
} 

# Pagination 
type CommerceConnection {
  edges: [CommerceEdge!]!
  pageInfo: CommercePageInfo!
}

type CommerceEdge {
  cursor: ID!
  node: Commerce
}

type CommercePageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewCommerce {
  # Descriptif
  name: String!
  description: String
  storekeeperWord: String

  # Coordonnées
  address: String!
  latitude: Float!
  longitude: Float!
  phone: String!
  email: String!

  facebook: String
  twitter: String
  instagram: String

  profilePicture: Upload
  image: Upload
}

input ChangesCommerce {
  # Descriptif
  name: String
  description: String
  storekeeperWord: String

  # Coordonnées
  address: String
  latitude: Float
  longitude: Float
  phone: String
  email: String

  facebook: String
  twitter: String
  instagram: String

  profilePicture: Upload
  image: Upload

  productsAvailableForClickAndCollect: [ID!]
}

# PRODUITS

type Product {
  id: ID!
  name: String!
  description: String!
  price: Float!
  unit: String!
  tva: Float!
  isBreton: Boolean!

  tags: [String!]
  categories: [String!]!
}

# Pagination
type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: ProductPageInfo!
}

type ProductEdge {
  cursor: ID!
  node: Product
}

type ProductPageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewProduct {
  name: String!
  description: String!
  price: Float!
  unit: String!
  tva: Float!
  isBreton: Boolean!

  tags: [String!]
  categories: [String!]!

  image: Upload
}

input ChangesProduct {
  name: String
  description: String
  price: Float
  unit: String
  tva: Float
  isBreton: Boolean

  tags: [String!]
  categories: [String!]

  image: Upload
}

input BulkChangesProduct {
  id: ID!
  changes: ChangesProduct!
}

#######################
## CLICK AND COLLECT ##
#######################

type CCProduct {
  quantity: Int!
  product: Product!
}

type CCCommand {
  id: ID!
  status: String!
  products: [CCProduct!]!

  pickupDate: Time!

  user: User!
}

# Pagination 
type CCCommandConnection {
  edges: [CCCommandEdge!]!
  pageInfo: CCCommandPageInfo!
}

type CCCommandEdge {
  cursor: ID!
  node: CCCommand
}

type CCCommandPageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewCCProcuct {
  quantity: Int!
  productID: ID!
}

input NewCCCommand {
  productsID: [NewCCProcuct!]
  pickupDate: Time!
}

input ChangesCCCommand {
  status: String
}

#############
## PANIERS ##
#############


type PanierProduct {
  quantity: Int!
  product: Product!
}

type Panier {
  id: ID!
  name: String!
  description: String!
  type: String!
  category: String!

  quantity: Int!
  price: Float!
  reduction: Float!

  endingDate: Time

  products: [PanierProduct!]!
}

# Pagination 
type PanierConnection {
  edges: [PanierEdge!]!
  pageInfo: PanierPageInfo!
}

type PanierEdge {
  cursor: ID!
  node: Panier
}

type PanierPageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

# Edition/création

input NewPanierProduct {
  quantity: Int!
  productID: ID!
}

input NewPanier {
  name: String!
  description: String!
  type: String!
  category: String!

  quantity: Int!
  price: Float!
  reduction: Float!

  image: Upload
  endingDate: Time

  products: [NewPanierProduct!]
}

input ChangesPanier {
  name: String
  description: String
  category: String

  quantity: Int
  price: Float
  reduction: Float

  image: Upload
  endingDate: Time

  products: [NewPanierProduct!]
}

type PanierCommand {
  id: ID!
  status: String!
  panier: Panier!

  pickupDate: Time!

  user: User!
}

# Pagination 
type PanierCommandConnection {
  edges: [PanierCommandEdge!]!
  pageInfo: PanierCommandPageInfo!
}

type PanierCommandEdge {
  cursor: ID!
  node: PanierCommand
}

type PanierCommandPageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewPanierCommand {
  panierID: String!
  pickupDate: Time!
}

input ChangesPanierCommand {
  status: String
}

############
## BASKET ##
############

type BasketProduct {
  quantity: Float!
  product: Product!
}

type BasketCommerce {
  commerce: Commerce!
  products: [BasketProduct!]!
  paniers: [Panier]!
}

type Basket {
  commerces: [BasketCommerce!]!
}

input NewBasket {
  commerces: [NewBasketCommerce!]!
}

input NewBasketCommerce {
  commerceID: ID!,
  products: [NewBasketProduct!]!
  paniers: [ID!]!
  pickupDate: Time
}

input NewBasketProduct {
  quantity: Float!
  productID: ID!
}

#############
## FILTERS ##
#############

input Filter {
  key: String!
  value: String!
}

input CommerceFilter {
  nearLatitude: Float
  nearLongitude: Float
  radius: Float
}


input ProductFilter {
  category: String
}

input CCCommandFilter {
  status: String
}

input PanierCommandFilter {
  status: String
}

input PanierFilter {
  type: String
}

type Query {
  # UTILISATEURS
  users: [User!]!
  user(id: ID): User!

  # COMMERCES
  commerces(first: Int = 5, after: ID, filter: CommerceFilter): CommerceConnection! 
  commerce(id: ID): Commerce
  product(id: ID!): Product!

  # SERVICES
  # CLICK AND COLLECT
  cccommand(id: ID!): CCCommand! @needAuthentication

  # PANIERS
  panier(id: ID!): Panier!
  paniercommand(id: ID!): PanierCommand! @needAuthentication
}

type Mutation {
  # UTILISATEURS
  createUser(input: NewUser!): User!
  login(input: Login!): String!

  # COMMERCES
  createCommerce(userID: ID!, input: NewCommerce!): Commerce! 
  updateCommerce(id: ID!, changes: ChangesCommerce!): Commerce! @hasRole(role: STOREKEEPER)
  createProduct(commerceID: ID, input: NewProduct!): Product! @hasRole(role: STOREKEEPER)
  createProducts(commerceID: ID, input: [NewProduct!]!): [Product!]! @hasRole(role: STOREKEEPER)
  updateProduct(id: ID!, changes: ChangesProduct!): Product! @hasRole(role: STOREKEEPER)
  updateProducts(changes: [BulkChangesProduct!]!): [Product!]! @hasRole(role: STOREKEEPER)

  # SERVICES
  # CLICK AND COLLECT
  updateCCCommand(id: ID!, changes: ChangesCCCommand): CCCommand! @hasRole(role: STOREKEEPER)

  # PANIER
  createPanier(commerceID: ID, input: NewPanier!): Panier! @hasRole(role: STOREKEEPER)
  updatePanier(id: ID! changes: ChangesPanier!): Panier! @hasRole(role: STOREKEEPER)
  updatePanierCommand(id: ID!, changes: ChangesPanierCommand): PanierCommand! @hasRole(role: STOREKEEPER)
}
