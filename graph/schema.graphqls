directive @hasRole(role: Role!) on FIELD_DEFINITION
directive @needAuthentication on FIELD_DEFINITION

enum Role {
  ADMIN,
  STOREKEEPER,
  USER
}

scalar Time
scalar Upload

##################
## UTILISATEURS ##
##################

type User {
  id: ID!
  createdAt: Time
  email: String!
  role: String!
  firstName: String
  lastName: String

  commerce: Commerce
}

input NewUser {
  email: String!
  password: String!
  firstName: String
  lastName: String
}

input Login {
  email: String!
  password: String!
}

###############
## COMMERCE ##
###############

# COMMERCE
# Utilisation de la pagination par curseur : https://www.apollographql.com/blog/graphql/pagination/understanding-pagination-rest-graphql-and-relay/

type Commerce { # Ici on utilise le nom "Commerce"
                # plutôt que "Store" pour éviter de 
                # futures conflits
  id: ID!
  storekeeper: User!
  
  # Descriptif
  name: String!
  description: String!
  storekeeperWord: String!

  # Coordonnées
  address: String!
  phone: String!
  email: String!

  # Produits
  categories: [String!]!
  products(first: Int = 10, after: ID, filters: ProductFilter): ProductConnection!

  # Services
  services: [String!]!

  # Click and collcet
  cccommands(first: Int = 10, after: ID, filters: CCCommandFilter): CCCommandConnection!
} 

# Pagination 
type CommerceConnection {
  edges: [CommerceEdge!]!
  pageInfo: CommercePageInfo!
}

type CommerceEdge {
  cursor: ID!
  node: Commerce
}

type CommercePageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewCommerce {
  # Descriptif
  name: String!
  description: String!
  storekeeperWord: String!

  # Coordonnées
  address: String!
  phone: String!
  email: String!
}

# PRODUITS

type Product {
  id: ID!
  name: String!
  description: String!
  price: Float!
  unit: String!
  isBreton: Boolean!

  tags: [String!]
  categories: [String!]!
}

# Pagination
type ProductConnection {
  edges: [ProductEdge!]!
  pageInfo: ProductPageInfo!
}

type ProductEdge {
  cursor: ID!
  node: Product
}

type ProductPageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewProduct {
  commerceID: ID

  name: String!
  description: String!
  price: Float!
  unit: String!
  isBreton: Boolean!

  tags: [String!]
  categories: [String!]!

  image: Upload
}

input ChangesProduct {
  name: String
  description: String
  price: Float
  unit: String
  isBreton: Boolean

  tags: [String!]
  categories: [String!]

  image: Upload
}


#######################
## CLICK AND COLLECT ##
#######################

type CCProduct {
  quantity: Int!
  product: Product!
}

type CCCommand {
  id: ID!
  status: String!
  products: [CCProduct!]!

  pickupDate: Time!

  user: User!
}

# Pagination 
type CCCommandConnection {
  edges: [CCCommandEdge!]!
  pageInfo: CCCommandPageInfo!
}

type CCCommandEdge {
  cursor: ID!
  node: CCCommand
}

type CCCommandPageInfo {
  startCursor: ID!
  endCursor: ID!
  hasNextPage: Boolean!
}

input NewCCProcuct {
  quantity: Int!
  productID: ID!
}

input NewCCCommand {
  productsID: [NewCCProcuct!]
  pickupDate: Time!
}

input ChangesCCCommand {
  status: String
}

#############
## FILTERS ##
#############

input Filter {
  key: String!
  value: String!
}

input ProductFilter {
  category: String
}

input CCCommandFilter {
  status: String
}

type Query {
  # UTILISATEURS
  users: [User!]!
  user(id: ID): User!

  # COMMERCES
  commerces(first: Int = 5, after: ID): CommerceConnection! 
  commerce(id: ID): Commerce
  product(id: ID!): Product!

  # CLICK AND COLLECT
  cccommand(id: ID!): CCCommand! @needAuthentication
}

type Mutation {
  # UTILISATEURS
  createUser(input: NewUser!): User!
  login(input: Login!): String!

  # COMMERCES
  createCommerce(input: NewCommerce!): Commerce! @hasRole(role: STOREKEEPER) 
  createProduct(input: NewProduct!): Product! @hasRole(role: STOREKEEPER)
  updateProduct(id: ID!, changes: ChangesProduct): Product! @hasRole(role: STOREKEEPER)

  # SERVICES
  # CLICK AND COLLECT
  order(commerceID: ID!, command: NewCCCommand!): CCCommand! @needAuthentication
  updateCCCommand(id: ID!, changes: ChangesCCCommand): CCCommand @hasRole(role: STOREKEEPER)
}
